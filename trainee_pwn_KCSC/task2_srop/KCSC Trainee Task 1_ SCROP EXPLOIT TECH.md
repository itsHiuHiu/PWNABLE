---
title: 'KCSC Trainee Task 1: SCROP EXPLOIT TECH'

---

# KCSC Trainee Task 1: SCROP EXPLOIT TECH
![{2F0AB7CB-C0DB-48FB-AD7B-2C54D54E8CDD}](https://hackmd.io/_uploads/BysW2eI5kx.png)

## IDA
* Dịch ngược file ta có:
* ![{E1A737DB-1969-4095-A38B-6BD27F0A4A89}](https://hackmd.io/_uploads/SJ5RTeLqkx.png)
* Bảng hàm chỉ tồn tại 2 hàm là main và start nên ta cùng khảo sát 2 hàm này:
* Hàm main:
> ![{80A1F47C-5426-45A4-9D65-F7E7AC855404}](https://hackmd.io/_uploads/Hyr-0l8qkg.png)
> Đầu tiên các biến v3 v4 và v8 được khai báo.
> Gán biến v3 là số byte đã ghi thành công từ việc ghi 0x45 byte dữ liệu và biến toàn cục welcome.
> Gán biến v4 là số byte đã đọc thành công từ dữ liệu đầu vào của người dùng có kích thước 0x200 byte.
> Hàm thực hiện loại bỏ kí tự xuống dòng.
> Sau đó thực hiện sao chép 0x14 byte từ địa chỉ biến prefix và biến banner.
> Và sao chép số byte đã được đọc từ dữ liệu đầu vào từ dữ liệu đầu vào (v8) và phần tử thứ 20 của biến banner.
> Thực hiện sao chép chuỗi kí tự vào phần tử thứ [v4+ 20] của banner và thực hiện trả về là việc in ra màn hình biến banner.

* Hàm start:
> ![{C7265BB2-2164-4CC1-BA60-7119C837FD20}](https://hackmd.io/_uploads/ry7y-WL5kl.png)
> Khai báo các biến v0, v1, v2, v3.
> Biến v0 được gán với 0x4d8 byte được in thành công ra màn hình từ biến banner.
> Thực hiện gọi hàm main với các tham số là 1, biến banner, v1
> Gán v2 là hàm exit hệ thống.
> Cuối cùng hàm trả về việc gọi hàm main với tham số 0, biến banner và v3.

## Ý tưởng
* Ta nhận thấy tồn tại lỗi tràn biến tại dữ liệu đầu vào của biến v8 khi biến này chỉ được khai báo 200 byte nhưng hàm sys_read lại cho phép nhập vào 0x200 byte.
* Tuy nhiên ta không thấy hàm nào có khả năng tạo shell cho ta nên ta sẽ hướng đến việc sử dụng shellcode hoặc gadget, SROP để thực thi system("/bin/sh").
* Tại challenge này ta sẽ hướng đến việc sử dụng kĩ thuật SROP (mặc dù ret2shellcode được vì anh zai tắt NX rồi:)))) )

## Khai thác
* Sử dụng công cụ GDB để khai thác:
* Kiểm tra các phương pháp bảo vệ của chương trình:
> ![{998D0543-CC6A-438D-AAAE-B544D7F6F2AD}](https://hackmd.io/_uploads/HJ95mW8c1l.png)
> Ta chú ý đến Stack không có Canary, No PIE địa chỉ tĩnh.
* Ta tiến hành khảo sát stack trước và sau khi dữ liệu được nhập ta thấy rằng:
> ![{B6EE4DA1-5309-4F30-B2E2-6C9C76D4AF6C}](https://hackmd.io/_uploads/rysvVW8qyg.png)
> Và ta tìm được offset đến saved rip là 208 byte.
* Với việc sử dụng kĩ thuật SROP ta tận dụng syscall sigret vì syscall này chỉ yêu cầu syscall number là đủ sử dụng bởi trong bài này các gadget để điều khiển các thanh ghi rdi, rsi, rdx vốn là các tham số cần thiết để thực thi execve("/bin/sh",0,0). 
> ![{5F2A3818-1CD9-4D11-9B72-983996B6BED0}](https://hackmd.io/_uploads/B1G0S-L9yx.png)
* Và với kết quả tìm kiếm trên ta tận dụng luôn gadget pop rax, ret. Tiếp theo ta chỉ cần tìm gadget syscall nữa để ta có thể sử dụng syscall sigret.
> ![{F8FD5CA2-8116-43C5-A4EA-3F9E4AAF3E34}](https://hackmd.io/_uploads/SJoIYWIcJl.png)

* Như vậy đến bước này ta đã có tương đối đã có thể sử dụng được sigret. Hàm sigret sẽ lấy dữ liệu trên stack để thiết lập cho tất cả các thanh ghi (trừ rax) và với ứng dụng đó ta sẽ thiết lập các thanh ghi như rax, rdi, rsi, rdx thành các chỉ số phù hợp để thực thi system('/bin/sh',0,0).
* Ta sẽ thay thế địa chỉ trả về bằng gadget pop rax và tham số 0xf (syscall number của sigret) và sau đó là gadget sigret để thực thi hàm. Đồng thời, pwntools cũng có tính năng hỗ trợ để ta có thể thiết lập nhanh chóng các thanh ghi: SigreturnFrame(). Ta tiến hành thiết lập với script:
* ![{72680665-CC0E-4866-BE3C-A4E0AE4770DF}](https://hackmd.io/_uploads/BJO8a-8cye.png)
* Tuy nhiên tồn tại một vấn đề là chuỗi /bin/sh. Ta cần thiết lập chuỗi đó cho thanh ghi rdi nhưng khi tìm kiếm trên bộ nhớ thì ta hoàn toàn không có sẵn. Vậy chỉ còn cách ta nhập vào và lấy địa chỉ nơi lưu chuỗi gán vào shell thôi. 
* Tồn tại vấn đề tiếp theo là nếu ta nhập chuỗi vào stack thì ta không thể trực tiếp lấy địa chỉ stack được vì mỗi lần chạy địa chỉ stack mỗi khác. Nhưng mà chương trình có để lại cho ta một dữ kiện quan trọng:
> ![{5D4BC6AA-803B-44E7-9E9C-E02FB0F9662F}](https://hackmd.io/_uploads/Bk9eC-I51e.png)
> Ta nhận thấy rằng khi chạy chương trình và nhập liệu thì sau đó chương trình sẽ in ra dữ liệu ta nhập vào kèm với một chuỗi kí tự mặc định.
> Khi ta khảo sát chương trình thì ta thấy rằng chuỗi ta nhập vào còn được lưu trong một phân vùng có quyền read và write chứ không chỉ ở stack:
> ![{6017DF0E-4E4C-4902-9982-B9070DC454B5}](https://hackmd.io/_uploads/H1xNgG891e.png)
> Ta có thể thấy tại skip+82 chương trình đang ghi ra màn hình dữ liệu từ vùng nhớ có kí hiệu là banner và ta thấy rằng tồn tại chuỗi kí tự ta nhập vào, thử kiểm tra dữ liệu tại đó:
> ![{692ACB15-C8DB-420D-BB52-4B5D75C45B95}](https://hackmd.io/_uploads/B1lulzIc1x.png)
> Ta thấy rằng tại gần địa chỉ banner+16 đang tồn tại các byte từ chuỗi ta nhập vào. Với điều này, ta sẽ cho nhập chuỗi /bin/sh vào và bằng cách khảo sát vùng dữ liệu banner ta sẽ tìm thấy được địa chỉ chứa chuỗi và thiết lập cho biến shell.
> ![{66AB92C6-C9C8-4966-9C5B-386EA4220910}](https://hackmd.io/_uploads/BktPWGIckl.png)
> Sau khi cho chạy thử với payload đã bổ sung chuỗi /bin/sh ta cũng đã tìm được địa chỉ nơi đang lưu chuỗi trên:
> ![{66AB92C6-C9C8-4966-9C5B-386EA4220910}](https://hackmd.io/_uploads/SJqFZfUc1e.png)
> Ta tiến hành lấy địa chỉ này thiết lập cho biến shell và chạy lại chương trình:
> ![{EFC21D54-C811-4E0D-8AD7-37F98B9978CD}](https://hackmd.io/_uploads/HJWaZfI91x.png)
>![{94E9184F-55B3-4283-8723-ECB6AE318FDB}](https://hackmd.io/_uploads/SJbkMf8qkg.png)

=> "KCSC_TRAINEE{_Nice_srop_with_the_useful_output_bro_!}"

* Như vậy ta đã thành công tạo được shell, challenge hoàn thành!